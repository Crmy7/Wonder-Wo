// server/api/maux/search.post.ts
import { getCurrentUser } from '~/server/utils/auth-middleware'
import { Op } from 'sequelize'

// Types pour les r√©sultats
interface ProduitRecette {
  id: number
  nom: string
  nomScientifique: string
  dansPlacard: boolean
  imageUrl: string
  proprietes: string
}

interface ResultatRecherche {
  id: string
  type: 'recette' | 'produit_simple'
  nomRecette: string
  description: string
  typeApplication: string
  produits: ProduitRecette[]
  produitsPlacardDisponibles: number
  sourceDocumentaire: string
  adapteAuProfil: boolean
  raisonNonAdapte: string | null
  score: number
  categorie: string
  imageUrl: string
  efficacite: number
}

interface ProfilUtilisateur {
  age?: number
  grossesse?: boolean
  enfants?: boolean
}

export default defineEventHandler(async (event) => {
  try {
    // V√©rifier l'authentification
    const IdUser = await getCurrentUser(event)
    
    const body = await readBody(event)
    const { symptome, profil }: { symptome: string, profil?: ProfilUtilisateur } = body

    // Validation des donn√©es
    if (!symptome || !symptome.trim()) {
      throw createError({
        statusCode: 400,
        statusMessage: 'Sympt√¥me requis pour la recherche'
      })
    }

    // Essayer la base de donn√©es d'abord
    try {
      console.log('üîç [ETAPE 1] D√©but recherche pour sympt√¥me:', symptome, 'utilisateur:', IdUser)
      
      const { Maux, Produit, Recettes, Placard } = await import('~/server/database')
      console.log('‚úÖ [ETAPE 1] Import des mod√®les r√©ussi')
      
      // 1. R√©cup√©rer les produits du placard de l'utilisateur
      console.log('üîç [ETAPE 2] R√©cup√©ration du placard pour utilisateur:', IdUser)
      const placardUtilisateur = await Placard.findAll({
        where: { IdUser },
        raw: true
      }) as any[]
      
      const produitsPlacardIds: number[] = placardUtilisateur.map((item: any) => item.IdProduit)
      console.log('‚úÖ [ETAPE 2] Produits dans le placard:', produitsPlacardIds.length, 'produits ->', produitsPlacardIds)

      // 2. Recherche dans les maux correspondant au sympt√¥me
      console.log('üîç [ETAPE 3] Recherche dans les maux avec sympt√¥me:', symptome)
      const mauxTrouves = await Maux.findAll({
        where: {
          Symptom: {
            [Op.like]: `%${symptome}%`
          }
        },
        raw: true
      }) as any[]

      console.log('‚úÖ [ETAPE 3] Maux trouv√©s:', mauxTrouves.length, 'r√©sultats')
      if (mauxTrouves.length > 0) {
        console.log('üìù [ETAPE 3] Premiers maux:', mauxTrouves.slice(0, 3).map(m => m.Symptom))
      }

      // 3. Recherche directe dans les produits par propri√©t√©s
      console.log('üîç [ETAPE 4] Recherche dans les produits avec sympt√¥me:', symptome)
      const produitsRecommandes = await Produit.findAll({
        where: {
          [Op.or]: [
            {
              Propriete_Principale: {
                [Op.like]: `%${symptome}%`
              }
            },
            {
              Propriete_Secondaire: {
                [Op.like]: `%${symptome}%`
              }
            },
            {
              Utilisation: {
                [Op.like]: `%${symptome}%`
              }
            }
          ]
        },
        attributes: [
          'id', 'Nom_Commun', 'Nom_Scientifique', 
          'Propriete_Principale', 'Propriete_Secondaire',
          'Utilisation', 'Precautions', 'Image_url'
        ],
        raw: true
      }) as any[]

      console.log('‚úÖ [ETAPE 4] Produits trouv√©s:', produitsRecommandes.length, 'r√©sultats')
      if (produitsRecommandes.length > 0) {
        console.log('üìù [ETAPE 4] Premiers produits:', produitsRecommandes.slice(0, 3).map(p => p.Nom_Commun))
      }

      // 4. Formater et prioriser les r√©sultats
      console.log('üîç [ETAPE 5] Formatage des r√©sultats')
      const resultats: ResultatRecherche[] = []

      // Fonction pour v√©rifier l'adaptation au profil
      const estAdapteAuProfil = (recette?: any): boolean => {
        if (!profil || !recette) return true
        
        // V√©rifier grossesse
        if (profil.grossesse && recette.Femme_Enceinte === false) {
          return false
        }
        
        // V√©rifier tranche d'√¢ge (codes: 1=enfant, 2=adulte, 3=senior)
        if (profil.age && recette.Tranche_age) {
          if (profil.age < 12 && recette.Tranche_age > 1) return false
          if (profil.age > 65 && recette.Tranche_age === 1) return false
        }
        
        return true
      }

      // Fonction pour calculer le score de priorit√©
      const calculerScore = (produitIds: number[], hasRecette: boolean = false): number => {
        let score = 0.5 // Score de base
        
        // Boost si produits du placard disponibles
        const produitsPlacardDansRecette = produitIds.filter(id => 
          produitsPlacardIds.includes(id)
        )
        
        if (produitsPlacardDansRecette.length > 0) {
          score += 0.4 + (produitsPlacardDansRecette.length * 0.1)
        }
        
        // Boost pour les recettes vs produits simples
        if (hasRecette) {
          score += 0.2
        }
        
        return Math.min(score, 1.0) // Cap √† 1.0
      }

      // 5. IGNORER les produits simples - on veut seulement des vraies recettes
      console.log('üîç [ETAPE 6] Produits trouv√©s ignor√©s (on veut seulement des recettes):', produitsRecommandes.length)

      // 6. Pour les maux trouv√©s, chercher leurs VRAIES recettes via les tables de liaison
      console.log('üîç [ETAPE 7] Recherche des vraies recettes pour les maux trouv√©s:', mauxTrouves.length)
      
      for (const mal of mauxTrouves) {
        try {
          console.log(`üîç [ETAPE 7] Recherche recettes pour mal: "${mal.Symptom}" (ID: ${mal.id})`)
          
          // Trouver les recettes li√©es √† ce mal via la table RecetteMaux
          const recettesLiees = await Recettes.findAll({
            include: [
              {
                model: Maux,
                as: 'maux',
                where: { id: mal.id },
                through: { attributes: [] }
              }
            ],
            attributes: [
              'id', 'Type_Remede', 'Type_Application', 'Recette',
              'Tranche_age', 'Femme_Enceinte', 'Source_Documentaire', 'Efficacite'
            ],
            raw: false // On garde les objets Sequelize pour les relations
          })
          
          console.log(`üìù [ETAPE 7] Recettes trouv√©es pour "${mal.Symptom}": ${recettesLiees.length}`)
          
          // Log d√©taill√© de chaque recette trouv√©e
          recettesLiees.forEach((recette, index) => {
            console.log(`üìã [ETAPE 7] Recette ${index + 1}: ID=${(recette as any).id}, Type=${(recette as any).Type_Remede}, Description="${(recette as any).Recette?.substring(0, 50)}..."`)
          })
          
          // Pour chaque recette, trouver ses produits
          for (const recette of recettesLiees) {
            try {
              const produitsRecette = await Produit.findAll({
                include: [
                  {
                    model: Recettes,
                    as: 'recettes',
                    where: { id: (recette as any).id },
                    through: { attributes: [] }
                  }
                ],
                attributes: [
                  'id', 'Nom_Commun', 'Nom_Scientifique', 
                  'Propriete_Principale', 'Image_url'
                ],
                raw: true
              }) as any[]
              
              console.log(`üìù [ETAPE 7] Produits pour recette ${(recette as any).id}: ${produitsRecette.length}`)
              
              // Log des produits trouv√©s ou manquants
              if (produitsRecette.length > 0) {
                console.log(`üìã [ETAPE 7] Produits de la recette ${(recette as any).id}:`, produitsRecette.map(p => `${p.Nom_Commun} (ID: ${p.id})`))
              } else {
                console.warn(`‚ö†Ô∏è [ETAPE 7] AUCUN PRODUIT trouv√© pour recette ${(recette as any).id} - AFFICH√âE QUAND M√äME`)
                console.warn(`‚ö†Ô∏è [ETAPE 7] D√©tails recette sans produits: Type=${(recette as any).Type_Remede}, Description="${(recette as any).Recette?.substring(0, 100)}..."`)
              }
              
              // Toujours traiter la recette, m√™me sans produits
              {
                const produitIds = produitsRecette.map(p => p.id)
                const score = calculerScore(produitIds, true)
                const adapte = estAdapteAuProfil(recette)
                
                const resultatRecette: ResultatRecherche = {
                  id: `mal-${mal.id}-recette-${(recette as any).id}`,
                  idRecette: (recette as any).id,
                  type: 'recette',
                  nomRecette: `${getTypeRemede((recette as any).Type_Remede)} pour ${mal.Symptom}`,
                  description: (recette as any).Recette || `Recette traditionnelle pour traiter ${mal.Symptom}`,
                  typeApplication: getTypeApplication((recette as any).Type_Application),
                  produits: produitsRecette.length > 0 
                    ? produitsRecette.map((p: any): ProduitRecette => ({
                        id: p.id,
                        nom: p.Nom_Commun,
                        nomScientifique: p.Nom_Scientifique,
                        dansPlacard: produitsPlacardIds.includes(p.id),
                        imageUrl: p.Image_url || 'üåø',
                        proprietes: p.Propriete_Principale || ''
                      }))
                    : [{
                        id: 0,
                        nom: 'Recette sans produits d√©taill√©s',
                        nomScientifique: 'V√©rifiez la base de donn√©es',
                        dansPlacard: false,
                        imageUrl: '‚ùì',
                        proprietes: 'Aucun produit associ√© dans RecetteProduit'
                      }],
                  produitsPlacardDisponibles: produitIds.filter(id => produitsPlacardIds.includes(id)).length,
                  sourceDocumentaire: (recette as any).Source_Documentaire || 'Pharmacop√©e traditionnelle',
                  adapteAuProfil: adapte,
                  raisonNonAdapte: !adapte ? getRaisonNonAdapte(recette, profil) : null,
                  score,
                  categorie: 'Recette traditionnelle',
                  imageUrl: getIconeRemede((recette as any).Type_Remede),
                  efficacite: (recette as any).Efficacite || 0.8
                }
                
                resultats.push(resultatRecette)
                console.log(`‚úÖ [ETAPE 7] Ajout√© recette: "${resultatRecette.nomRecette}"`)
              }
            } catch (errProduits: any) {
              console.warn(`‚ö†Ô∏è [ETAPE 7] Erreur r√©cup√©ration produits pour recette ${(recette as any).id}:`, errProduits.message)
            }
          }
        } catch (errRecettes: any) {
          console.warn(`‚ö†Ô∏è [ETAPE 7] Erreur r√©cup√©ration recettes pour mal "${mal.Symptom}":`, errRecettes.message)
        }
      }

      // 7. IGNORER la recherche secondaire par propri√©t√©s - on veut seulement des vraies recettes
      console.log('üîç [ETAPE 8] Recherche secondaire ignor√©e (on veut seulement des recettes)')

      // 8. √âliminer les doublons et trier par score de priorit√©
      console.log('üîç [ETAPE 8] Finalisation - r√©sultats bruts:', resultats.length)
      console.log('üìã [ETAPE 8] R√©sultats bruts d√©taill√©s:', resultats.map(r => `${r.id} - ${r.nomRecette}`))
      
      const resultatsUniques = resultats.filter((resultat, index, self) => 
        index === self.findIndex(r => r.id === resultat.id)
      )
      
      console.log('‚úÖ [ETAPE 8] R√©sultats uniques:', resultatsUniques.length)
      console.log('üìã [ETAPE 8] R√©sultats uniques d√©taill√©s:', resultatsUniques.map(r => `${r.id} - ${r.nomRecette}`))
      
      resultatsUniques.sort((a, b) => {
        // Tri par nombre de produits placard disponibles
        if (b.produitsPlacardDisponibles !== a.produitsPlacardDisponibles) {
          return b.produitsPlacardDisponibles - a.produitsPlacardDisponibles
        }
        // Puis par score global
        return b.score - a.score
      })
      
      console.log('‚úÖ [ETAPE 8] R√©sultats tri√©s par priorit√© (placard, score)')

      const response = {
        success: true,
        symptome,
        profil,
        resultats: resultatsUniques.slice(0, 15), // Limiter √† 15 r√©sultats
        count: resultatsUniques.length,
        placardInfo: {
          totalProduits: produitsPlacardIds.length,
          recettesAvecPlacard: resultatsUniques.filter(r => r.produitsPlacardDisponibles > 0).length,
          recettesSansPlacard: resultatsUniques.filter(r => r.produitsPlacardDisponibles === 0).length
        },
        message: `${resultatsUniques.length} recette(s) trouv√©e(s) pour "${symptome}"`
      }
      
      console.log('üéâ [ETAPE 9] SUCC√àS - R√©ponse finale:', {
        symptome: response.symptome,
        count: response.count,
        placardInfo: response.placardInfo
      })
      
      return response

    } catch (dbError: any) {
      console.error('‚ùå [ERREUR DB] Erreur base de donn√©es:', dbError.message)
      console.error('‚ùå [ERREUR DB] Stack:', dbError.stack)
      throw createError({
        statusCode: 503,
        statusMessage: 'Base de donn√©es non disponible. Veuillez v√©rifier que MySQL est d√©marr√© et configur√©.'
      })
    }

  } catch (error: any) {
    console.error('‚ùå [ERREUR GENERALE] Erreur recherche maux:', error.message)
    console.error('‚ùå [ERREUR GENERALE] Stack:', error.stack)
    
    if (error.statusCode) {
      throw error
    }
    
    throw createError({
      statusCode: 500,
      statusMessage: 'Erreur serveur lors de la recherche de rem√®des'
    })
  }
})

// Fonctions utilitaires
function getTypeRemede(code: number): string {
  const types = {
    1: 'Tisane/Infusion',
    2: 'D√©coction',
    3: 'Cataplasme',
    4: 'Huile/Baume',
    5: 'Sirop',
    6: 'Teinture',
    7: 'Autre'
  }
  return types[code as keyof typeof types] || 'Rem√®de naturel'
}

function getTypeApplication(code: number): string {
  const types = {
    1: 'Usage interne',
    2: 'Usage externe',
    3: 'Inhalation',
    4: 'Bain',
    5: 'Gargarisme',
    6: 'Autre'
  }
  return types[code as keyof typeof types] || 'Usage sp√©cifique'
}

function getIconeRemede(code: number): string {
  const icones = {
    1: 'ü´ñ', // Tisane
    2: 'ü•É', // D√©coction
    3: 'üåø', // Cataplasme
    4: 'ü´í', // Huile
    5: 'üçØ', // Sirop
    6: 'üíß', // Teinture
    7: 'üå±'  // Autre
  }
  return icones[code as keyof typeof icones] || 'üåø'
}

function getRaisonNonAdapte(recette: any, profil: ProfilUtilisateur | undefined): string {
  if (!profil) return ''
  
  const raisons: string[] = []
  
  if (profil.grossesse && !recette.Femme_Enceinte) {
    raisons.push('Non recommand√© pendant la grossesse')
  }
  
  if (profil.age && recette.Tranche_age) {
    if (profil.age < 12 && recette.Tranche_age > 1) {
      raisons.push('Non adapt√© aux enfants')
    }
    if (profil.age > 65 && recette.Tranche_age === 1) {
      raisons.push('Con√ßu pour les enfants')
    }
  }
  
  return raisons.join(', ')
}