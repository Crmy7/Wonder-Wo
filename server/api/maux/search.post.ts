// server/api/maux/search.post.ts
import { getCurrentUser } from '~/server/utils/auth-middleware'
import { Op } from 'sequelize'

// Types pour les r√©sultats
interface ProduitRecette {
  id: number
  nom: string
  nomScientifique: string
  dansPlacard: boolean
  imageUrl: string
  proprietes: string
}

interface ResultatRecherche {
  id: string
  type: 'recette' | 'produit_simple'
  nomRecette: string
  description: string
  typeApplication: string
  produits: ProduitRecette[]
  produitsPlacardDisponibles: number
  sourceDocumentaire: string
  adapteAuProfil: boolean
  raisonNonAdapte: string | null
  score: number
  categorie: string
  imageUrl: string
  efficacite: number
}

interface ProfilUtilisateur {
  age?: number
  grossesse?: boolean
  enfants?: boolean
}

export default defineEventHandler(async (event) => {
  try {
    // V√©rifier l'authentification
    const IdUser = await getCurrentUser(event)
    
    const body = await readBody(event)
    const { symptome, profil }: { symptome: string, profil?: ProfilUtilisateur } = body

    // Validation des donn√©es
    if (!symptome || !symptome.trim()) {
      throw createError({
        statusCode: 400,
        statusMessage: 'Sympt√¥me requis pour la recherche'
      })
    }

    // Essayer la base de donn√©es d'abord
    try {
      console.log('üîç [ETAPE 1] D√©but recherche pour sympt√¥me:', symptome, 'utilisateur:', IdUser)
      
      const { Maux, Produit, Recettes, Placard } = await import('~/server/database')
      console.log('‚úÖ [ETAPE 1] Import des mod√®les r√©ussi')
      
      // 1. R√©cup√©rer les produits du placard de l'utilisateur
      console.log('üîç [ETAPE 2] R√©cup√©ration du placard pour utilisateur:', IdUser)
      const placardUtilisateur = await Placard.findAll({
        where: { IdUser },
        raw: true
      }) as any[]
      
      const produitsPlacardIds: number[] = placardUtilisateur.map((item: any) => item.IdProduit)
      console.log('‚úÖ [ETAPE 2] Produits dans le placard:', produitsPlacardIds.length, 'produits ->', produitsPlacardIds)

      // 2. Recherche dans les maux correspondant au sympt√¥me
      console.log('üîç [ETAPE 3] Recherche dans les maux avec sympt√¥me:', symptome)
      const mauxTrouves = await Maux.findAll({
        where: {
          Symptom: {
            [Op.like]: `%${symptome}%`
          }
        },
        raw: true
      }) as any[]

      console.log('‚úÖ [ETAPE 3] Maux trouv√©s:', mauxTrouves.length, 'r√©sultats')
      if (mauxTrouves.length > 0) {
        console.log('üìù [ETAPE 3] Premiers maux:', mauxTrouves.slice(0, 3).map(m => m.Symptom))
      }

      // 3. Recherche directe dans les produits par propri√©t√©s
      console.log('üîç [ETAPE 4] Recherche dans les produits avec sympt√¥me:', symptome)
      const produitsRecommandes = await Produit.findAll({
        where: {
          [Op.or]: [
            {
              Propriete_Principale: {
                [Op.like]: `%${symptome}%`
              }
            },
            {
              Propriete_Secondaire: {
                [Op.like]: `%${symptome}%`
              }
            },
            {
              Utilisation: {
                [Op.like]: `%${symptome}%`
              }
            }
          ]
        },
        attributes: [
          'id', 'Nom_Commun', 'Nom_Scientifique', 
          'Propriete_Principale', 'Propriete_Secondaire',
          'Utilisation', 'Precautions', 'Image_url'
        ],
        raw: true
      }) as any[]

      console.log('‚úÖ [ETAPE 4] Produits trouv√©s:', produitsRecommandes.length, 'r√©sultats')
      if (produitsRecommandes.length > 0) {
        console.log('üìù [ETAPE 4] Premiers produits:', produitsRecommandes.slice(0, 3).map(p => p.Nom_Commun))
      }

      // 4. Formater et prioriser les r√©sultats
      console.log('üîç [ETAPE 5] Formatage des r√©sultats')
      const resultats: ResultatRecherche[] = []

      // Fonction pour v√©rifier l'adaptation au profil
      const estAdapteAuProfil = (recette?: any): boolean => {
        if (!profil || !recette) return true
        
        // V√©rifier grossesse
        if (profil.grossesse && recette.Femme_Enceinte === false) {
          return false
        }
        
        // V√©rifier tranche d'√¢ge (codes: 1=enfant, 2=adulte, 3=senior)
        if (profil.age && recette.Tranche_age) {
          if (profil.age < 12 && recette.Tranche_age > 1) return false
          if (profil.age > 65 && recette.Tranche_age === 1) return false
        }
        
        return true
      }

      // Fonction pour calculer le score de priorit√©
      const calculerScore = (produitIds: number[], hasRecette: boolean = false): number => {
        let score = 0.5 // Score de base
        
        // Boost si produits du placard disponibles
        const produitsPlacardDansRecette = produitIds.filter(id => 
          produitsPlacardIds.includes(id)
        )
        
        if (produitsPlacardDansRecette.length > 0) {
          score += 0.4 + (produitsPlacardDansRecette.length * 0.1)
        }
        
        // Boost pour les recettes vs produits simples
        if (hasRecette) {
          score += 0.2
        }
        
        return Math.min(score, 1.0) // Cap √† 1.0
      }

      // 5. Traiter les produits trouv√©s directement
      console.log('üîç [ETAPE 6] Traitement des produits trouv√©s:', produitsRecommandes.length)
      for (const produit of produitsRecommandes) {
        const dansPlacard = produitsPlacardIds.includes(produit.id)
        const score = calculerScore([produit.id], false)
        console.log(`üìù [ETAPE 6] Produit: ${produit.Nom_Commun}, dans placard: ${dansPlacard}, score: ${score}`)
        
        // Ajouter le produit comme rem√®de simple
        const resultatProduit: ResultatRecherche = {
          id: `produit-${produit.id}`,
          type: 'produit_simple',
          nomRecette: `Usage de ${produit.Nom_Commun}`,
          description: produit.Utilisation || `Rem√®de naturel √† base de ${produit.Nom_Commun}`,
          typeApplication: 'Usage direct',
          produits: [{
            id: produit.id,
            nom: produit.Nom_Commun,
            nomScientifique: produit.Nom_Scientifique,
            dansPlacard,
            imageUrl: produit.Image_url || 'üåø',
            proprietes: produit.Propriete_Principale || ''
          }],
          produitsPlacardDisponibles: dansPlacard ? 1 : 0,
          sourceDocumentaire: 'Propri√©t√©s th√©rapeutiques',
          adapteAuProfil: true,
          raisonNonAdapte: null,
          score,
          categorie: 'Produit naturel',
          imageUrl: produit.Image_url || 'üåø',
          efficacite: 0.7
        }
        resultats.push(resultatProduit)
      }

      // 6. Pour les maux trouv√©s, chercher des recettes potentielles
      // (Simplification - on pourrait ajouter une logique plus complexe plus tard)
      console.log('üîç [ETAPE 7] Traitement des maux trouv√©s:', mauxTrouves.length)
      if (mauxTrouves.length > 0) {
        // Cr√©er un rem√®de g√©n√©rique bas√© sur le premier mal trouv√©
        const premierMal = mauxTrouves[0]
        const produitsLies = produitsRecommandes.slice(0, 3) // Prendre les 3 premiers produits
        console.log(`üìù [ETAPE 7] Premier mal: ${premierMal.Symptom}, produits li√©s: ${produitsLies.length}`)
        
        if (produitsLies.length > 0) {
          const produitIds = produitsLies.map(p => p.id)
          const score = calculerScore(produitIds, true)
          
          const resultatMal: ResultatRecherche = {
            id: `mal-${premierMal.id}-combinaison`,
            type: 'recette',
            nomRecette: `Rem√®de naturel pour ${premierMal.Symptom}`,
            description: `Combinaison de plantes pour traiter ${premierMal.Symptom}. Utilisation traditionnelle recommand√©e.`,
            typeApplication: 'Usage interne',
            produits: produitsLies.map((p: any): ProduitRecette => ({
              id: p.id,
              nom: p.Nom_Commun,
              nomScientifique: p.Nom_Scientifique,
              dansPlacard: produitsPlacardIds.includes(p.id),
              imageUrl: p.Image_url || 'üåø',
              proprietes: p.Propriete_Principale || ''
            })),
            produitsPlacardDisponibles: produitIds.filter(id => produitsPlacardIds.includes(id)).length,
            sourceDocumentaire: 'Pharmacop√©e traditionnelle',
            adapteAuProfil: true,
            raisonNonAdapte: null,
            score,
            categorie: 'Recette traditionnelle',
            imageUrl: 'ü´ñ',
            efficacite: 0.8
          }
          resultats.push(resultatMal)
        }
      }

      // 7. √âliminer les doublons et trier par score de priorit√©
      console.log('üîç [ETAPE 8] Finalisation - r√©sultats bruts:', resultats.length)
      const resultatsUniques = resultats.filter((resultat, index, self) => 
        index === self.findIndex(r => r.id === resultat.id)
      )
      
      console.log('‚úÖ [ETAPE 8] R√©sultats uniques:', resultatsUniques.length)
      
      resultatsUniques.sort((a, b) => {
        // D'abord par nombre de produits placard disponibles
        if (b.produitsPlacardDisponibles !== a.produitsPlacardDisponibles) {
          return b.produitsPlacardDisponibles - a.produitsPlacardDisponibles
        }
        // Puis par score global
        return b.score - a.score
      })
      
      console.log('‚úÖ [ETAPE 8] R√©sultats tri√©s par priorit√©')

      const response = {
        success: true,
        symptome,
        profil,
        resultats: resultatsUniques.slice(0, 15), // Limiter √† 15 r√©sultats
        count: resultatsUniques.length,
        placardInfo: {
          totalProduits: produitsPlacardIds.length,
          recettesAvecPlacard: resultatsUniques.filter(r => r.produitsPlacardDisponibles > 0).length,
          recettesSansPlacard: resultatsUniques.filter(r => r.produitsPlacardDisponibles === 0).length
        },
        message: `${resultatsUniques.length} rem√®de(s) trouv√©(s) pour "${symptome}"`
      }
      
      console.log('üéâ [ETAPE 9] SUCC√àS - R√©ponse finale:', {
        symptome: response.symptome,
        count: response.count,
        placardInfo: response.placardInfo
      })
      
      return response

    } catch (dbError: any) {
      console.error('‚ùå [ERREUR DB] Erreur base de donn√©es:', dbError.message)
      console.error('‚ùå [ERREUR DB] Stack:', dbError.stack)
      throw createError({
        statusCode: 503,
        statusMessage: 'Base de donn√©es non disponible. Veuillez v√©rifier que MySQL est d√©marr√© et configur√©.'
      })
    }

  } catch (error: any) {
    console.error('‚ùå [ERREUR GENERALE] Erreur recherche maux:', error.message)
    console.error('‚ùå [ERREUR GENERALE] Stack:', error.stack)
    
    if (error.statusCode) {
      throw error
    }
    
    throw createError({
      statusCode: 500,
      statusMessage: 'Erreur serveur lors de la recherche de rem√®des'
    })
  }
})

// Fonctions utilitaires
function getTypeRemede(code: number): string {
  const types = {
    1: 'Tisane/Infusion',
    2: 'D√©coction',
    3: 'Cataplasme',
    4: 'Huile/Baume',
    5: 'Sirop',
    6: 'Teinture',
    7: 'Autre'
  }
  return types[code as keyof typeof types] || 'Rem√®de naturel'
}

function getTypeApplication(code: number): string {
  const types = {
    1: 'Usage interne',
    2: 'Usage externe',
    3: 'Inhalation',
    4: 'Bain',
    5: 'Gargarisme',
    6: 'Autre'
  }
  return types[code as keyof typeof types] || 'Usage sp√©cifique'
}

function getIconeRemede(code: number): string {
  const icones = {
    1: 'ü´ñ', // Tisane
    2: 'ü•É', // D√©coction
    3: 'üåø', // Cataplasme
    4: 'ü´í', // Huile
    5: 'üçØ', // Sirop
    6: 'üíß', // Teinture
    7: 'üå±'  // Autre
  }
  return icones[code as keyof typeof icones] || 'üåø'
}

function getRaisonNonAdapte(recette: any, profil: ProfilUtilisateur | undefined): string {
  if (!profil) return ''
  
  const raisons: string[] = []
  
  if (profil.grossesse && !recette.Femme_Enceinte) {
    raisons.push('Non recommand√© pendant la grossesse')
  }
  
  if (profil.age && recette.Tranche_age) {
    if (profil.age < 12 && recette.Tranche_age > 1) {
      raisons.push('Non adapt√© aux enfants')
    }
    if (profil.age > 65 && recette.Tranche_age === 1) {
      raisons.push('Con√ßu pour les enfants')
    }
  }
  
  return raisons.join(', ')
}